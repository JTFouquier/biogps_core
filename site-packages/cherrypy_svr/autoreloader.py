#This code is modified from werkzeug.serving
#in order to remove unneccessary files to monitor
#Instead, it will just monitor files as provided.
#
#OK, I made a settings below to toggle two different behaviors
#   if True, it will monitor all files  (when files are all local)
#   otherwise, it will only monitor files specified in extra_files   (when files are on slow network drive)
#  Chunlei Wu 05/11/2011
MONITOR_ALL_FILES = True

import sys, os, time, thread
from itertools import chain
from werkzeug._internal import _log

from django.utils.autoreload import code_changed
def reloader_loop(extra_files=None, interval=1):
    while 1:
        if code_changed():
            _log('info', ' * Detected change, reloading')
            sys.exit(3) # force reload
        time.sleep(interval)

def reloader_loop0(extra_files=None, interval=1):
    """When this function is run from the main thread, it will force other
    threads to exit when any modules currently loaded change.

    Copyright notice.  This function is based on the autoreload.py from
    the CherryPy trac which originated from WSGIKit which is now dead.

    :param extra_files: a list of additional files it should watch.
    """
    def iter_module_files():
        for module in sys.modules.values():
            filename = getattr(module, '__file__', None)
            if filename:
                while not os.path.isfile(filename):
                    filename = os.path.dirname(filename)
                    if not filename:
                        break
                else:
                    if filename[-4:] in ('.pyc', '.pyo'):
                        filename = filename[:-1]
                    yield filename

    mtimes = {}
    file_list = chain(iter_module_files(), extra_files or ()) if MONITOR_ALL_FILES else (extra_files or ())
    print len(list(file_list))
    while 1:
        for filename in file_list:
            try:
                mtime = os.stat(filename).st_mtime
            except OSError:
                continue

            old_time = mtimes.get(filename)
            if old_time is None:
                mtimes[filename] = mtime
                continue
            elif mtime > old_time:
                _log('info', ' * Detected change in %r, reloading' % filename)
                sys.exit(3)
        time.sleep(interval)



def restart_with_reloader():
    """Spawn a new Python interpreter with the same arguments as this one,
    but running the reloader thread.
    """
    while 1:
        _log('info', ' * Restarting with reloader...')
        args = [sys.executable] + sys.argv
        if sys.platform == 'win32':
            args = ['"%s"' % arg for arg in args]
        new_environ = os.environ.copy()
        new_environ['WERKZEUG_RUN_MAIN'] = 'true'
        exit_code = os.spawnve(os.P_WAIT, sys.executable, args, new_environ)
        if exit_code != 3:
            return exit_code


def run_with_reloader(main_func, extra_files=None, interval=1):
    """Run the given function in an independent python interpreter."""
    if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':
        thread.start_new_thread(main_func, ())
        try:
            reloader_loop(extra_files, interval)
        except KeyboardInterrupt:
            return
    try:
        sys.exit(restart_with_reloader())
    except KeyboardInterrupt:
        pass
